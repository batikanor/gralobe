<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Huawei Challenge: Geo-Spatial Histogram</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Roboto, sans-serif; }
        #ui-layer {
            position: absolute;
            top: 20px; right: 20px; width: 300px;
            background: rgba(10, 20, 30, 0.85);
            border: 1px solid #00aaff;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.2);
            padding: 20px;
            border-radius: 12px;
            color: white;
            backdrop-filter: blur(10px);
        }
        h1 { font-size: 16px; margin: 0 0 10px 0; color: #00aaff; letter-spacing: 2px; text-transform: uppercase; }
        p { font-size: 12px; color: #88ccff; margin-bottom: 20px; line-height: 1.4; }
        .slider-container { margin-bottom: 15px; }
        label { display: block; font-size: 11px; text-transform: uppercase; color: #5588aa; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00aaff; }
        .metrics { display: flex; justify-content: space-between; margin-top: 10px; font-size: 10px; font-family: monospace; color: #00aaff; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>Holographic Geo-Graph</h1>
    <p>Demonstrating seamless transition from 2D Analytical View to 3D Contextual View.</p>
    
    <div class="slider-container">
        <label>Form Factor (Unfold <-> Fold)</label>
        <input type="range" id="morph" min="0" max="1" step="0.001" value="0">
    </div>

    <div class="slider-container">
        <label>Data Extrusion (Graph Height)</label>
        <input type="range" id="extrusion" min="0" max="3" step="0.01" value="1.5">
    </div>

    <div class="metrics">
        <span>FPS: 60</span>
        <span>GPU: ACTIVE</span>
        <span>PTS: 65,000</span>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">
    uniform float uTime;
    uniform float uMorph;     // 0 = Plane, 1 = Sphere
    uniform float uExtrusion; // Height of data bars
    uniform sampler2D uMap;   // Earth Texture

    varying vec2 vUv;
    varying float vAmount;    // How "land-like" is this pixel?
    varying float vIsData;    // Is this a graph bar?

    #define PI 3.14159265359

    // Random function for data simulation
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
        vUv = uv;
        
        // Read the earth map texture (Brightness determines land)
        vec4 mapData = texture2D(uMap, uv);
        float brightness = mapData.r; // Assuming B/W map

        // --- DATA VISUALIZATION LOGIC ---
        // We only want points on land (brightness > 0.2)
        // We simulate "Cities" or "Data centers" using noise
        float cityNoise = smoothstep(0.6, 0.9, random(floor(uv * 60.0))); 
        
        // Combine Map with Noise to create 3D Graph Bars
        float elevation = 0.0;
        
        // If it is land
        if(brightness > 0.1) {
            elevation += 0.05; // Base land height
            
            // Add dynamic "Graph Bars" pulsing on top of land
            float pulse = sin(uTime * 3.0 + uv.x * 10.0) * 0.5 + 0.5;
            if(cityNoise > 0.5) {
                elevation += cityNoise * uExtrusion * pulse;
                vIsData = 1.0;
            } else {
                vIsData = 0.0;
            }
        }
        
        vAmount = elevation;

        // --- GEOMETRY MORPHING ---
        
        // 1. Plane Coordinates
        // Centered width/height
        vec3 planePos = position;
        planePos.z += elevation; // Graph bars grow Up in Z

        // 2. Sphere Coordinates
        float sphereRadius = 24.0;
        // Adjust UV to wrap correctly (standard WebGL sphere mapping)
        float phi = (0.5 - uv.y) * PI;      // Latitude
        float theta = (uv.x + 0.5) * 2.0 * PI; // Longitude (offset to center Europe/Africa)

        // Standard Sphere math
        vec3 spherePos;
        spherePos.x = sphereRadius * cos(phi) * cos(theta);
        spherePos.y = sphereRadius * sin(phi);
        spherePos.z = sphereRadius * cos(phi) * sin(theta); // Z is depth here
        
        // Calculate Sphere Normal for extrusion
        vec3 sphereNormal = normalize(spherePos);
        
        // Apply Graph Height radially
        spherePos += sphereNormal * elevation;

        // 3. Morph Mix
        vec3 finalPos = mix(planePos, spherePos, uMorph);

        // Size handling: Data bars get bigger points
        gl_PointSize = (vIsData > 0.5) ? 4.0 : 1.5;
        // Scale points by perspective
        gl_PointSize *= (30.0 / -modelViewMatrix[3].z); 

        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    varying vec2 vUv;
    varying float vAmount;
    varying float vIsData;
    uniform float uMorph;

    void main() {
        // Render Circular Points
        float dist = distance(gl_PointCoord, vec2(0.5));
        if (dist > 0.5) discard;

        // COLORS
        vec3 colorOcean = vec3(0.05, 0.1, 0.2); // Dark Deep Blue
        vec3 colorLand  = vec3(0.1, 0.4, 0.6);  // Muted Blue Land
        vec3 colorGraph = vec3(0.0, 1.0, 0.8);  // Cyan Graph Bars
        vec3 colorPeak  = vec3(1.0, 1.0, 1.0);  // White/Hot peaks

        vec3 finalColor = colorOcean;

        // If elevation suggests land
        if (vAmount > 0.02) {
            finalColor = colorLand;
        }

        // If it is a Data Graph Bar
        if (vIsData > 0.5) {
            // Gradient based on height
            finalColor = mix(colorGraph, colorPeak, vAmount * 0.3);
        }

        // Add a scanline effect for "Tech" feel
        float scanline = sin(vUv.y * 100.0) * 0.1;
        finalColor += scanline;

        // Opacity handling
        float alpha = 1.0;
        if(vAmount < 0.02) alpha = 0.3; // Make oceans transparent

        gl_FragColor = vec4(finalColor, alpha);
    }
</script>

<script>
    // --- 1. GENERATE EARTH MAP TEXTURE (Programmatic) ---
    // Since we can't load external images easily in a single file POC without CORS,
    // We will draw a simplified "World Map" onto a canvas and use it as a texture.
    // In a real production app, you would load 'earth_specular.jpg'
    
    function createEarthTexture() {
        const size = 1024;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size/2;
        const ctx = canvas.getContext('2d');

        // Fill Ocean (Black)
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, size, size/2);

        // Draw Stylized Continents (White)
        ctx.fillStyle = '#FFFFFF';
        
        // Very rough approximations of continents for the POC visually
        // North America
        ctx.beginPath(); ctx.ellipse(250, 150, 100, 80, 0.2, 0, Math.PI*2); ctx.fill();
        // South America
        ctx.beginPath(); ctx.ellipse(320, 350, 60, 100, -0.2, 0, Math.PI*2); ctx.fill();
        // Europe
        ctx.beginPath(); ctx.ellipse(530, 130, 50, 40, 0, 0, Math.PI*2); ctx.fill();
        // Africa
        ctx.beginPath(); ctx.ellipse(550, 280, 90, 110, 0, 0, Math.PI*2); ctx.fill();
        // Asia
        ctx.beginPath(); ctx.ellipse(750, 150, 140, 90, 0, 0, Math.PI*2); ctx.fill();
        // Australia
        ctx.beginPath(); ctx.ellipse(850, 380, 60, 50, 0, 0, Math.PI*2); ctx.fill();
        
        // Add random noise to make it look like coastlines/terrain
        // This simulates "Real Geography" resolution in the shader
        const imgData = ctx.getImageData(0,0, size, size/2);
        const data = imgData.data;
        for(let i=0; i < data.length; i+=4) {
            if(data[i] > 100) { // If inside a continent ellipse
                if(Math.random() > 0.1) data[i] = 255; // Coastline noise
                else data[i] = 0;
            }
        }
        ctx.putImageData(imgData, 0, 0);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    // --- 2. THREE.JS SETUP ---
    let scene, camera, renderer, material, points;
    let uTime = 0;

    function init() {
        scene = new THREE.Scene();
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 65; // Zoomed out to see the plane

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- GEOMETRY ---
        // High density plane to allow for smooth sphere wrapping
        // 360 x 180 corresponds to lat/long degrees
        const geometry = new THREE.PlaneBufferGeometry(80, 40, 360, 180);

        // --- MATERIAL ---
        material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uExtrusion: { value: 1.5 },
                uMap: { value: createEarthTexture() }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- LISTENERS ---
        window.addEventListener('resize', onResize);
        
        document.getElementById('morph').addEventListener('input', (e) => {
            material.uniforms.uMorph.value = parseFloat(e.target.value);
        });
        document.getElementById('extrusion').addEventListener('input', (e) => {
            material.uniforms.uExtrusion.value = parseFloat(e.target.value);
        });
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        uTime += 0.01;
        material.uniforms.uTime.value = uTime;
        
        // Slowly rotate only if in Sphere mode for effect
        if(material.uniforms.uMorph.value > 0.5) {
            points.rotation.y += 0.002;
        } else {
            // Reset rotation when flat for readability
            points.rotation.y = points.rotation.y * 0.95; 
        }

        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>
