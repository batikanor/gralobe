<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Huawei Challenge: The Perfect Fold</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #hud {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 400px; padding: 20px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #445566;
            border-radius: 8px;
            color: #fff; text-align: center;
            backdrop-filter: blur(5px);
        }
        h2 { margin: 0 0 10px 0; font-size: 14px; color: #00aaff; letter-spacing: 2px; text-transform: uppercase; }
        input[type=range] { width: 100%; accent-color: #00aaff; cursor: pointer; }
        .labels { display: flex; justify-content: space-between; font-size: 10px; color: #8899aa; margin-top: 5px; }
    </style>
</head>
<body>

<div id="hud">
    <h2>Cylindrical Rolling Engine</h2>
    <input type="range" id="morph" min="0" max="1" step="0.005" value="0">
    <div class="labels">
        <span>FLAT MAP</span>
        <span>ROLLING</span>
        <span>TRUE GLOBE</span>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const TEXTURE_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg';
</script>

<script type="x-shader/x-vertex" id="vertexShader">
    uniform float uTime;
    uniform float uMorph; // 0 to 1
    uniform sampler2D uMap;

    varying vec2 vUv;
    varying float vElevation;

    const float PI = 3.14159265359;
    const float RADIUS = 35.0;

    // ROTATION MATRIX FUNCTION
    mat3 rotateY(float angle) {
        float c = cos(angle);
        float s = sin(angle);
        return mat3(
            c, 0, s,
            0, 1, 0,
            -s, 0, c
        );
    }

    void main() {
        vUv = uv;

        // 1. DATA ELEVATION (The Graph)
        // Read texture for landmass
        vec4 texData = texture2D(uMap, uv);
        float land = texData.r;
        
        // Create scanning wave
        float scan = smoothstep(0.0, 0.1, sin(uv.x * 10.0 + uTime * 2.0));
        float elevation = 0.0;
        if(land > 0.1) {
            elevation = land * (0.5 + scan * 2.0); // Pulse the data
        }
        vElevation = elevation;

        // 2. THE GEOMETRY FOLDING LOGIC
        // Instead of mixing positions, we TRANSFORM the flat plane.
        
        // Base Flat Position (Centered)
        // Width is 2*PI*RADIUS (Circumference), Height is PI*RADIUS (Half Circumference)
        float width = 2.0 * PI * RADIUS;
        float height = PI * RADIUS;
        
        vec3 pos = vec3(
            (uv.x - 0.5) * width,
            (uv.y - 0.5) * height,
            0.0
        );

        // Apply Data Elevation (Z-up in Flat Mode)
        pos.z += elevation * 2.0;

        // --- THE "ROLLING" ALGORITHM ---
        
        // Angle to wrap: 0 degrees (Flat) -> 360 degrees (Sphere)
        float wrapAngle = uMorph * 2.0 * PI;
        
        // A. CYLINDRICAL WRAP (Longitude)
        // We bend the plane around the Y-axis.
        // Effective Radius shrinks from Infinity to RADIUS.
        
        if (uMorph > 0.001) {
            // Distance of this vertex from the center of the plane
            float xOffset = (uv.x - 0.5) * width;
            
            // Current radius of the cylinder we are forming
            // As uMorph goes to 1, radius goes to RADIUS
            // We use a math trick: Radius = ArcLength / Angle
            // Avoid divide by zero
            float currentRadius = width / wrapAngle;
            
            // Map X-position to Angle
            float theta = (uv.x - 0.5) * wrapAngle;
            
            // Cylinder Equation
            pos.x = sin(theta) * currentRadius;
            pos.z = (cos(theta) - 1.0) * currentRadius; // Offset so center stays at 0
            
            // Add elevation along the normal (radially out from cylinder center)
            vec3 cylNormal = normalize(vec3(sin(theta), 0.0, cos(theta)));
            pos += cylNormal * elevation * 2.0;
            
            // B. SPHERICAL PINCH (Latitude)
            // Now we curl the top and bottom in.
            // Only happens strongly as we approach uMorph = 1.0
            
            float pinchFactor = uMorph; // Linear pinch
            
            // Convert vertical Y-position to Latitude Angle
            float phi = (uv.y - 0.5) * PI; // -90 to +90
            
            // We want to mix between "Straight Y" and "Curved Y"
            // Sphere Y = R * sin(phi)
            float sphereY = RADIUS * sin(phi);
            // Cylinder Y = (uv.y - 0.5) * height
            
            // Smoothly transition Y
            pos.y = mix(pos.y, sphereY, pinchFactor);
            
            // Now the hard part: The Radius contraction at the poles.
            // On a sphere, radius at poles is 0. On cylinder, it's RADIUS.
            // Scale factor = cos(phi)
            float scaleFactor = mix(1.0, cos(phi), pinchFactor);
            
            // Apply scale to X and Z (shrinking the cylinder rings towards the poles)
            pos.x *= scaleFactor;
            pos.z *= scaleFactor;
        }

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        
        // SIZE
        gl_PointSize = 2.0;
        if(elevation > 1.0) gl_PointSize = 4.0;
        // Perspective Scale
        gl_PointSize *= (200.0 / -modelViewMatrix[3].z);
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    varying vec2 vUv;
    varying float vElevation;

    void main() {
        if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard;

        vec3 colWater = vec3(0.02, 0.04, 0.1);
        vec3 colLand  = vec3(0.1, 0.5, 0.7);
        vec3 colData  = vec3(0.0, 1.0, 0.9);

        vec3 finalColor = colWater;
        float alpha = 0.4;

        if (vElevation > 0.1) {
            finalColor = colLand;
            alpha = 0.8;
            if (vElevation > 0.8) {
                finalColor = colData;
            }
        }
        
        // Grid lines to show curvature
        float grid = 0.0;
        if (fract(vUv.x * 18.0) < 0.02 || fract(vUv.y * 9.0) < 0.02) {
             finalColor += vec3(0.2);
             alpha = 1.0;
        }

        gl_FragColor = vec4(finalColor, alpha);
    }
</script>

<script>
    let scene, camera, renderer, material, particles;
    let uTime = 0;

    function init() {
        scene = new THREE.Scene();
        
        // Camera setup
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 250);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const loader = new THREE.TextureLoader();
        // Load Real Earth
        loader.load(TEXTURE_URL, (tex) => {
            initEarth(tex);
        });
    }

    function initEarth(tex) {
        // High density geometry for smooth folding
        const geometry = new THREE.PlaneBufferGeometry(100, 50, 512, 256);

        material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uMap: { value: tex }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide // Important to see the back while folding
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        uTime += 0.01;
        if(material) material.uniforms.uTime.value = uTime;
        
        // Gentle rotation
        if(particles) particles.rotation.y = uTime * 0.05;

        renderer.render(scene, camera);
    }

    // UI Control
    document.getElementById('morph').addEventListener('input', (e) => {
        if(material) material.uniforms.uMorph.value = parseFloat(e.target.value);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
