<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Huawei Challenge: FluxGeo POC</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffff;
            padding: 20px;
            color: #fff;
            border-radius: 8px;
            width: 250px;
            backdrop-filter: blur(5px);
        }
        h2 { margin: 0 0 10px 0; font-size: 18px; color: #00ffff; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; color: #aaa; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00ffff; }
        .status { font-size: 10px; color: #00ffff; margin-top: 10px; text-align: right; }
        #explanation {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            max-width: 300px;
        }
    </style>
</head>
<body>

<div id="ui-container">
    <h2>FluxGeo Engine</h2>
    
    <div class="control-group">
        <label>Form Factor Morph (Fold/Unfold)</label>
        <input type="range" id="morphSlider" min="0" max="1" step="0.01" value="0">
    </div>

    <div class="control-group">
        <label>Data Spike Intensity</label>
        <input type="range" id="dataSlider" min="0" max="2" step="0.01" value="0.8">
    </div>

    <div class="status">:: GPU SHADER ACTIVE ::</div>
</div>

<div id="explanation">
    Drag to Rotate | Scroll to Zoom <br>
    Use slider to morph between GLOBE (Watch/Folded) and GRAPH (Tablet/PC).
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">
    uniform float uTime;
    uniform float uMorph; // 0.0 = Plane, 1.0 = Sphere
    uniform float uDataIntensity;
    
    varying vec2 vUv;
    varying float vElevation;
    varying float vMorphState;

    // Pseudo-random function for procedural data generation
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
        vUv = uv;
        vMorphState = uMorph;

        // 1. DATA GENERATION (Procedural "Graph" bars)
        // We use sine waves to simulate data clusters (like population or usage heatmaps)
        float wave = sin(uv.x * 20.0 + uTime) * sin(uv.y * 10.0 + uTime * 0.5);
        float noise = random(floor(uv * 40.0)); // Blocky "digital" look
        float elevation = wave * noise * uDataIntensity;
        
        // Make sure elevation is always positive for "bars"
        elevation = max(0.0, elevation); 
        vElevation = elevation;

        // 2. PLANE GEOMETRY DEFINITION
        // A flat grid centered at 0,0
        vec3 planePos = position; 
        planePos.z += elevation * 0.5; // Elevate Z on plane

        // 3. SPHERE GEOMETRY DEFINITION
        float radius = 25.0;
        
        // Map UV (0..1) to Spherical Coordinates
        float theta = uv.x * 2.0 * 3.14159; // Longitude
        float phi = uv.y * 3.14159;         // Latitude

        vec3 spherePos;
        // Standard spherical conversion
        spherePos.x = radius * sin(phi) * cos(theta);
        spherePos.y = radius * cos(phi);
        spherePos.z = radius * sin(phi) * sin(theta);

        // Extrude vertices OUTWARD from sphere center based on data
        vec3 sphereNormal = normalize(spherePos);
        spherePos += sphereNormal * elevation * 4.0; 

        // 4. THE MORPH
        // Interpolate between the flat position and the sphere position
        vec3 finalPos = mix(planePos, spherePos, uMorph);

        // 5. POINT SIZE
        // Make points close to camera larger
        gl_PointSize = 2.5 * (1.0 + elevation); 

        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    uniform float uTime;
    
    varying vec2 vUv;
    varying float vElevation;
    varying float vMorphState;

    void main() {
        // Color Palette: Huawei-esque Cyan, Blue, and Magenta
        vec3 colorLow = vec3(0.0, 0.2, 0.5);   // Dark Blue
        vec3 colorHigh = vec3(0.0, 1.0, 1.0);  // Cyan
        vec3 colorHot = vec3(1.0, 0.0, 0.8);   // Magenta for high data

        // Mix colors based on elevation (data value)
        vec3 finalColor = mix(colorLow, colorHigh, vElevation);
        if(vElevation > 0.6) {
            finalColor = mix(finalColor, colorHot, (vElevation - 0.6) * 2.0);
        }

        // Create a "Grid" effect by darkening pixels based on UV coordinates
        float gridX = step(0.95, fract(vUv.x * 40.0));
        float gridY = step(0.95, fract(vUv.y * 20.0));
        float grid = max(gridX, gridY);
        
        // Make the points circular
        float strength = distance(gl_PointCoord, vec2(0.5));
        strength = 1.0 - step(0.5, strength);

        if (strength < 0.1) discard;

        gl_FragColor = vec4(finalColor, strength * 0.8);
    }
</script>

<script>
    let scene, camera, renderer, material, geometry, particles;
    let uTime = 0;

    function init() {
        // 1. Setup Scene
        scene = new THREE.Scene();
        
        // 2. Setup Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;
        camera.position.y = 20;

        // 3. Setup Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // optimize for mobile
        document.body.appendChild(renderer.domElement);

        // 4. Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 5. Create the Geometry (High Segment Plane)
        // 200x100 segments = 20,000 data points
        geometry = new THREE.PlaneBufferGeometry(80, 40, 200, 100);

        // 6. Create the Shader Material
        material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 }, // Starts as Plane
                uDataIntensity: { value: 0.8 }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // 7. Create Points Mesh
        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 8. Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        
        // UI Listeners
        document.getElementById('morphSlider').addEventListener('input', (e) => {
            material.uniforms.uMorph.value = parseFloat(e.target.value);
        });
        document.getElementById('dataSlider').addEventListener('input', (e) => {
            material.uniforms.uDataIntensity.value = parseFloat(e.target.value);
        });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // Update Time
        uTime += 0.01;
        material.uniforms.uTime.value = uTime;

        // Rotate scene slightly for dynamic feel
        particles.rotation.y = uTime * 0.05;

        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>
