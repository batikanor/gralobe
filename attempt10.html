<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Huawei Challenge: Command Center</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        
        /* THE CONTROL PANEL */
        #gui {
            position: absolute; top: 0; left: 0; bottom: 0;
            width: 300px;
            background: rgba(10, 15, 20, 0.95);
            border-right: 1px solid #334455;
            padding: 20px;
            color: #ccc;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 5px 0 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h1 { font-size: 18px; color: #00E5FF; margin: 0 0 20px 0; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid #334455; padding-bottom: 10px; }
        h3 { font-size: 12px; color: #8899AA; margin: 20px 0 10px 0; text-transform: uppercase; letter-spacing: 1px; }
        
        .control { margin-bottom: 15px; }
        label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 5px; color: #aaa; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00E5FF; height: 4px; background: #334455; border-radius: 2px; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: #00E5FF; cursor: pointer; margin-top: -4px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #334455; border-radius: 2px; }

        .value-display { color: #fff; font-weight: bold; }

        /* HUD overlay */
        #hud {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right; pointer-events: none;
            color: #00E5FF; font-family: monospace; opacity: 0.7;
        }
    </style>
</head>
<body>

<div id="gui">
    <h1>Holographic Geo-Engine</h1>
    
    <h3>Form Factor (The Fold)</h3>
    <div class="control">
        <label>Morph State <span id="val_morph" class="value-display">0%</span></label>
        <input type="range" id="uMorph" min="0" max="1" step="0.001" value="0">
    </div>

    <h3>Visual Clarity</h3>
    <div class="control">
        <label>Point Size <span id="val_size" class="value-display">2.0px</span></label>
        <input type="range" id="uPointSize" min="1" max="6" step="0.1" value="2.0">
    </div>
    <div class="control">
        <label>Ocean Visibility <span id="val_ocean" class="value-display">20%</span></label>
        <input type="range" id="uOceanAlpha" min="0" max="1" step="0.01" value="0.2">
    </div>
    <div class="control">
        <label>Land Brightness <span id="val_land" class="value-display">80%</span></label>
        <input type="range" id="uLandAlpha" min="0" max="1" step="0.01" value="0.8">
    </div>

    <h3>Data Simulation</h3>
    <div class="control">
        <label>Elevation Height <span id="val_amp" class="value-display">3.0</span></label>
        <input type="range" id="uElevationAmp" min="0" max="10" step="0.1" value="3.0">
    </div>
    <div class="control">
        <label>Scan Speed <span id="val_speed" class="value-display">1.5</span></label>
        <input type="range" id="uScanSpeed" min="0" max="10" step="0.1" value="1.5">
    </div>
    <div class="control">
        <label>Scan Width <span id="val_width" class="value-display">0.2</span></label>
        <input type="range" id="uScanWidth" min="0.01" max="1.0" step="0.01" value="0.2">
    </div>
    <div class="control">
        <label>Data Threshold (Filter) <span id="val_thresh" class="value-display">0.15</span></label>
        <input type="range" id="uLandThreshold" min="0.0" max="0.5" step="0.01" value="0.15">
    </div>
</div>

<div id="hud">
    SYSTEM: ONLINE<br>
    RENDER: WEBGL2<br>
    ASSET: NASA/JPL SOURCE
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const TEXTURE_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg';
</script>

<script type="x-shader/x-vertex" id="vertexShader">
    uniform float uTime;
    uniform float uMorph;
    uniform sampler2D uMap;

    // Configurable Uniforms
    uniform float uElevationAmp;
    uniform float uScanSpeed;
    uniform float uScanWidth;
    uniform float uPointSize;
    uniform float uLandThreshold;

    varying vec2 vUv;
    varying float vElevation;
    varying float vIsLand;

    const float PI = 3.14159265359;
    const float RADIUS = 35.0;

    void main() {
        vUv = uv;

        // 1. READ TEXTURE
        vec4 texData = texture2D(uMap, uv);
        float landVal = texData.r; // 0 to 1
        
        // Filter noise (Clean up the map)
        if(landVal < uLandThreshold) landVal = 0.0;
        vIsLand = landVal;

        // 2. CALCULATE ANIMATED ELEVATION
        // Create a scanning bar that moves across X
        // We use 'fract' to make it loop repeatedly
        float scanPhase = fract(uv.x * 2.0 - uTime * 0.1 * uScanSpeed);
        
        // Bell curve shape for the scan line
        float scanShape = smoothstep(0.5 - uScanWidth, 0.5, scanPhase) * smoothstep(0.5 + uScanWidth, 0.5, scanPhase);
        
        // Calculate final elevation
        float elevation = 0.0;
        if (landVal > 0.0) {
            // Base height + Scan height
            elevation = landVal * 0.2 + (landVal * scanShape * uElevationAmp);
        }
        vElevation = elevation;

        // 3. MORPH GEOMETRY (The Cylindrical Roll)
        // Standard Map Dimensions
        float width = 2.0 * PI * RADIUS;
        float height = PI * RADIUS;
        
        vec3 posFlat = vec3(
            (uv.x - 0.5) * width,
            (uv.y - 0.5) * height,
            0.0
        );
        posFlat.z += elevation * 2.0; // Elevate UP on flat map

        // Calculate Roll Logic
        // We roll X around Y
        float rollAmt = clamp(uMorph * 1.1, 0.0, 1.0); // Roll finishes slightly before pinch
        float pinchAmt = smoothstep(0.7, 1.0, uMorph); // Pinch happens at the end

        float currentAngle = (uv.x - 0.5) * (rollAmt * 2.0 * PI);
        float currentRadius = RADIUS;
        if(rollAmt < 0.999) currentRadius = width / (rollAmt * 2.0 * PI + 0.001);

        vec3 posRoll;
        posRoll.x = sin(currentAngle) * currentRadius;
        posRoll.y = posFlat.y;
        posRoll.z = (cos(currentAngle) - 1.0) * currentRadius;

        // Apply Pinch (Sphere Polars)
        float phi = (0.5 - uv.y) * PI;
        float sphereY = RADIUS * sin(phi);
        
        // Mix Y
        posRoll.y = mix(posRoll.y, sphereY, pinchAmt);
        
        // Shrink Rings
        float ringScale = mix(1.0, cos(phi), pinchAmt);
        posRoll.x *= ringScale;
        posRoll.z *= ringScale;

        // Add Elevation (Normal Direction)
        // We approximate normal based on current roll position
        vec3 normal = normalize(vec3(posRoll.x, 0.0, posRoll.z));
        if(pinchAmt > 0.5) normal = normalize(posRoll);
        
        posRoll += normal * elevation;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(posRoll, 1.0);

        // 4. SIZE
        // Base size + Extra size for high data
        float size = uPointSize;
        if(vElevation > 1.0) size *= 1.5;
        
        // Perspective scaling
        gl_PointSize = size * (200.0 / -modelViewMatrix[3].z);
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    uniform float uOceanAlpha;
    uniform float uLandAlpha;

    varying vec2 vUv;
    varying float vElevation;
    varying float vIsLand;

    void main() {
        // Soft circular particle
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;
        float softEdge = 1.0 - smoothstep(0.3, 0.5, dist);

        // Colors
        vec3 cOcean = vec3(0.05, 0.1, 0.2);
        vec3 cLand  = vec3(0.2, 0.5, 0.8);
        vec3 cHigh  = vec3(0.0, 1.0, 1.0); // Cyan
        vec3 cHot   = vec3(1.0, 1.0, 1.0); // White

        vec3 finalColor = cOcean;
        float finalAlpha = uOceanAlpha;

        if (vIsLand > 0.0) {
            finalColor = cLand;
            finalAlpha = uLandAlpha;

            // Coloring based on elevation (Data Scanner)
            if (vElevation > 0.5) {
                finalColor = mix(cLand, cHigh, (vElevation - 0.5));
            }
            if (vElevation > 2.0) {
                finalColor = cHot;
            }
        }

        gl_FragColor = vec4(finalColor, finalAlpha * softEdge);
    }
</script>

<script>
    let scene, camera, renderer, material, points;
    let uTime = 0;
    
    // Configuration Object
    const config = {
        uMorph: 0,
        uPointSize: 2.0,
        uOceanAlpha: 0.2,
        uLandAlpha: 0.8,
        uElevationAmp: 3.0,
        uScanSpeed: 1.5,
        uScanWidth: 0.2,
        uLandThreshold: 0.15
    };

    function init() {
        scene = new THREE.Scene();
        
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 240);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Load Asset
        new THREE.TextureLoader().load(TEXTURE_URL, (tex) => {
            createSystem(tex);
        });

        setupUI();
        window.addEventListener('resize', onResize);
    }

    function createSystem(texture) {
        // 512x256 = 131,072 particles
        const geometry = new THREE.PlaneBufferGeometry(100, 50, 512, 256);

        material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uMap: { value: texture },
                // Inject config values
                uMorph: { value: config.uMorph },
                uPointSize: { value: config.uPointSize },
                uOceanAlpha: { value: config.uOceanAlpha },
                uLandAlpha: { value: config.uLandAlpha },
                uElevationAmp: { value: config.uElevationAmp },
                uScanSpeed: { value: config.uScanSpeed },
                uScanWidth: { value: config.uScanWidth },
                uLandThreshold: { value: config.uLandThreshold }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);
        animate();
    }

    function setupUI() {
        // Helper to link slider to config & uniform & label
        const link = (id, key, isPct = false) => {
            const el = document.getElementById(id);
            const valEl = document.getElementById('val_' + id.replace('u', '').toLowerCase().replace('morph','morph').replace('point','').replace('ocean','').replace('land','').replace('elevation','').replace('scan',''));
            
            el.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                config[key] = v;
                if(material) material.uniforms[key].value = v;
                
                // Update text label
                if(valEl) {
                    if(id === 'uMorph') valEl.innerText = Math.round(v * 100) + '%';
                    else if(id === 'uPointSize') valEl.innerText = v.toFixed(1) + 'px';
                    else if(id.includes('Alpha')) valEl.innerText = Math.round(v * 100) + '%';
                    else valEl.innerText = v.toFixed(2);
                }
            });
        };

        link('uMorph', 'uMorph');
        link('uPointSize', 'uPointSize');
        link('uOceanAlpha', 'uOceanAlpha');
        link('uLandAlpha', 'uLandAlpha');
        link('uElevationAmp', 'uElevationAmp');
        link('uScanSpeed', 'uScanSpeed');
        link('uScanWidth', 'uScanWidth');
        link('uLandThreshold', 'uLandThreshold');
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        uTime += 0.01;
        if(material) material.uniforms.uTime.value = uTime;
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>

