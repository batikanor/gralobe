<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Huawei Challenge: Orbital Wrap UI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', Roboto, sans-serif; }
        #ui-layer {
            position: absolute;
            bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 400px;
            background: rgba(10, 20, 30, 0.9);
            border: 1px solid #00aaff;
            box-shadow: 0 0 25px rgba(0, 170, 255, 0.3);
            padding: 25px;
            border-radius: 16px;
            color: white;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        h1 { font-size: 18px; margin: 0 0 15px 0; color: #00aaff; letter-spacing: 2px; text-transform: uppercase; }
        label { display: block; font-size: 12px; text-transform: uppercase; color: #5588aa; margin-bottom: 10px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00aaff; height: 5px; }
        .status { font-size: 10px; color: #00aaff; margin-top: 15px; opacity: 0.7; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>Orbital Wrap Engine</h1>
    <label>Geometry Curvature (Curved 2D <-> True 3D)</label>
    <input type="range" id="morph" min="0" max="1" step="0.005" value="0">
    <div class="status">VERTEX SHADER: BENDING GEOMETRY REAL-TIME</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">
    uniform float uMorph; // 0.0 to 1.0 range controlling the wrap
    varying vec2 vUv;
    varying vec3 vNormal;

    #define PI 3.14159265359

    void main() {
        vUv = uv;
        vNormal = normal;

        // --- STATE 1: The "Something-Curvation" 2D View ---
        // Start with standard planar positions
        vec3 planePos = position;
        
        // Apply a parabolic bend along the X-axis.
        // Pixels further from center (uv.x 0.5) get pushed back in Z.
        // This creates the "curved monitor" look.
        float distanceFromCenter = abs(uv.x - 0.5) * 2.0;
        float initialCurve = pow(distanceFromCenter, 2.5) * 15.0;
        planePos.z -= initialCurve * (1.0 - uMorph * 0.5); // Reduce this curve as we morph to sphere

        // --- STATE 2: The True 3D Sphere View ---
        float sphereRadius = 30.0;
        // Map UVs to spherical angles
        float phi = (0.5 - uv.y) * PI;       // Latitude (North/South)
        float theta = (uv.x + 0.5) * 2.0 * PI;  // Longitude (East/West)

        vec3 spherePos;
        spherePos.x = sphereRadius * sin(phi) * cos(theta);
        spherePos.y = sphereRadius * sin(phi);
        spherePos.z = sphereRadius * cos(phi) * sin(theta);

        // --- THE SMOOTH TRANSITION ---
        // We mix the curved plane position with the sphere position.
        vec3 finalPos = mix(planePos, spherePos, uMorph);

        // Recalculate normal for correct lighting during transition (approximation)
        vec3 sphereNormal = normalize(spherePos);
        vec3 planeNormal = vec3(0.0, 0.0, 1.0);
        // Tilt the plane normals slightly based on the initial curve
        planeNormal.x = (uv.x - 0.5) * 2.0;
        planeNormal = normalize(planeNormal);
        
        vNormal = normalize(mix(planeNormal, sphereNormal, uMorph));

        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    varying vec2 vUv;
    varying vec3 vNormal;
    uniform float uMorph;

    void main() {
        // --- PROCEDURAL GRID & BORDERS ---
        // Instead of a texture, we mathematically generate glowing lines.
        
        // Create Latitude and Longitude lines
        // fract(vUv * N) creates repeating patterns
        // step(0.98, ...) isolates thin lines at the edge of patterns
        float gridX = step(0.98, fract(vUv.x * 36.0)); // 36 Longitude lines (every 10 degrees)
        float gridY = step(0.98, fract(vUv.y * 18.0)); // 18 Latitude lines (every 10 degrees)
        float mainGrid = max(gridX, gridY);

        // Create subtler sub-grid lines
        float subGridX = step(0.95, fract(vUv.x * 72.0));
        float subGridY = step(0.95, fract(vUv.y * 36.0));
        float subGrid = max(subGridX, subGridY) * 0.3; // Dimmer

        float totalGrid = max(mainGrid, subGrid);

        // --- COLORS ---
        vec3 deepSpace = vec3(0.02, 0.04, 0.08); // Background color
        vec3 hologramBlue = vec3(0.0, 0.6, 1.0); // Main grid color
        vec3 brightHighlight = vec3(0.8, 0.9, 1.0); // Hotspots

        // Base color
        vec3 finalColor = deepSpace;

        // Add the grid
        finalColor += totalGrid * hologramBlue;

        // --- FRESNEL EFFECT (Edge Glowing) ---
        // Makes the edges of the curved geometry glow more than the center
        vec3 viewDirection = normalize(cameraPosition - vNormal); // Approximation in fragment
        // A simple hack for Fresnel in point-cloud/wireframe style scenarios where true normals are tricky
        float fresnelTerm = pow(1.0 - abs(dot(vec3(0.0, 0.0, 1.0), vNormal)), 3.0);
        
        // Intensify glow as it becomes a sphere
        float glowIntensity = 0.5 + uMorph * 0.5;
        finalColor += fresnelTerm * hologramBlue * glowIntensity;

        // Make the main grid lines super bright
        if(mainGrid > 0.5) {
             finalColor = mix(finalColor, brightHighlight, 0.8);
        }

        // Scanline texture effect
        finalColor *= 0.8 + 0.2 * sin(vUv.y * 200.0);

        gl_FragColor = vec4(finalColor, 1.0);
    }
</script>

<script>
    let scene, camera, renderer, material, mesh;
    let uMorphTarget = 0;
    let uMorphCurrent = 0;

    function init() {
        scene = new THREE.Scene();
        
        // Camera positioned to see the curved 2D view clearly
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 90);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 40;
        controls.maxDistance = 150;

        // --- GEOMETRY ---
        // A very dense plane is required for smooth bending.
        // We use 360x180 segments to match geographical coordinates.
        const geometry = new THREE.PlaneBufferGeometry(120, 60, 360, 180);

        // --- MATERIAL ---
        material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uMorph: { value: 0 }
            },
            side: THREE.DoubleSide, // Important so we see the back when it wraps
            transparent: true
        });

        // Using LineSegments instead of Points for a sharper border look
        // We need to convert the plane mesh into wireframe geometry
        const wireframeGeometry = new THREE.WireframeGeometry(geometry);
        mesh = new THREE.LineSegments(wireframeGeometry, material);
        scene.add(mesh);

        // --- LISTENERS ---
        window.addEventListener('resize', onResize);
        
        // Slider input determines the target morph state
        document.getElementById('morph').addEventListener('input', (e) => {
            uMorphTarget = parseFloat(e.target.value);
        });
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // Smooth interpolation for the slider movement (makes it feel heavy/physical)
        uMorphCurrent += (uMorphTarget - uMorphCurrent) * 0.05;
        material.uniforms.uMorph.value = uMorphCurrent;

        // Slow rotation that speeds up slightly when it's a sphere
        mesh.rotation.y += 0.001 + (uMorphCurrent * 0.002);
        // Tilt it slightly for a better view of the poles
        mesh.rotation.x = 0.2 * uMorphCurrent;

        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>
